:PROPERTIES:
:ID:       7f40418b-1936-4cda-b7f6-9a079283bdb4
:END:
#+TITLE: Structure

=db= is a simple map with two levels of nesting.

#+begin_src clojure :results silent :exports code

{[?table-id ?entity-id :as ref] {?key ?value}}

#+end_src

example

#+begin_src clojure :results silent :exports code

{[:person/id 1] {:person/id 1 :name "ivan" :age 18 :_friend #{[:person/id 2]}}
 [:person/id 2] {:person/id 2 :name "petr" :age 24 :friend #{[:person/id 1]}}}

#+end_src

no special =deftype= is used, but the implementation is based on =protocols=, which
allows =doxa= to be used together with any =kv store=, like =redis=, =firestore= or =lmdb=.

in the standard implementation, doxa keeps all the necessary stuff in the map
=metadata=, including index, last transaction, cache etc.

reference, is always a two-element vector. table-id must be a keyword where
=(name ?k)= returns =id=, i.e =db/id=, =people/id=, etc. in the case of several keys
that satisfy a condition, the behaviour will be unpredictable.

entity-id can by any value, which allows a great flexibility, and importantly is
descriptive, e.g =[:country/id :andora]=, =[:people/id [:marketing
"zbyszek.nowak@gmail.com"]]=.

references and back references are a own implementation of =ordered/set= based on
[[https://github.com/clj-commons/ordered/tree/master/src/flatland/ordered][flatland/ordered]]. unfortunately =flatland= it doesn't support =cljs=, so i decided to
rewrite it. the use of =ordered/set= ensures distinct values, while preserving the
order of insertion.
